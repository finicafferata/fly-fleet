// Performance optimization utilities with accessibility considerations\n\n// Web Vitals tracking with accessibility metrics\nexport interface PerformanceMetrics {\n  // Core Web Vitals\n  lcp?: number; // Largest Contentful Paint\n  fid?: number; // First Input Delay\n  cls?: number; // Cumulative Layout Shift\n  fcp?: number; // First Contentful Paint\n  ttfb?: number; // Time to First Byte\n  \n  // Accessibility-specific metrics\n  focusDelay?: number; // Time to first focusable element\n  screenReaderDelay?: number; // Time to screen reader content\n  keyboardResponseTime?: number; // Keyboard navigation responsiveness\n  colorContrastRatio?: number; // Average color contrast\n  \n  // Custom metrics\n  formCompletionTime?: number;\n  searchResponseTime?: number;\n  navigationTime?: number;\n}\n\n// Performance observer with accessibility awareness\nexport class AccessiblePerformanceObserver {\n  private metrics: PerformanceMetrics = {};\n  private observers: PerformanceObserver[] = [];\n  private callbacks: ((metrics: PerformanceMetrics) => void)[] = [];\n\n  constructor() {\n    this.initializeObservers();\n  }\n\n  private initializeObservers() {\n    // Core Web Vitals\n    this.observeLCP();\n    this.observeFID();\n    this.observeCLS();\n    this.observeFCP();\n    this.observeTTFB();\n    \n    // Accessibility metrics\n    this.observeFocusDelay();\n    this.observeKeyboardResponse();\n  }\n\n  private observeLCP() {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1] as PerformanceEntry & { startTime: number };\n        this.metrics.lcp = lastEntry.startTime;\n        this.notifyCallbacks();\n      });\n      observer.observe({ entryTypes: ['largest-contentful-paint'] });\n      this.observers.push(observer);\n    }\n  }\n\n  private observeFID() {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry: any) => {\n          this.metrics.fid = entry.processingStart - entry.startTime;\n        });\n        this.notifyCallbacks();\n      });\n      observer.observe({ entryTypes: ['first-input'] });\n      this.observers.push(observer);\n    }\n  }\n\n  private observeCLS() {\n    if ('PerformanceObserver' in window) {\n      let clsValue = 0;\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry: any) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n          }\n        });\n        this.metrics.cls = clsValue;\n        this.notifyCallbacks();\n      });\n      observer.observe({ entryTypes: ['layout-shift'] });\n      this.observers.push(observer);\n    }\n  }\n\n  private observeFCP() {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry: any) => {\n          if (entry.name === 'first-contentful-paint') {\n            this.metrics.fcp = entry.startTime;\n          }\n        });\n        this.notifyCallbacks();\n      });\n      observer.observe({ entryTypes: ['paint'] });\n      this.observers.push(observer);\n    }\n  }\n\n  private observeTTFB() {\n    if ('performance' in window && 'timing' in performance) {\n      const navigation = performance.timing;\n      this.metrics.ttfb = navigation.responseStart - navigation.navigationStart;\n      this.notifyCallbacks();\n    }\n  }\n\n  private observeFocusDelay() {\n    let focusStartTime: number | null = null;\n    \n    // Measure time to first focusable element\n    const measureFocusDelay = () => {\n      if (focusStartTime === null) {\n        focusStartTime = performance.now();\n      }\n      \n      const focusableElements = document.querySelectorAll(\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      );\n      \n      if (focusableElements.length > 0) {\n        this.metrics.focusDelay = performance.now() - focusStartTime;\n        this.notifyCallbacks();\n      }\n    };\n\n    // Check on DOM ready and after mutations\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', measureFocusDelay);\n    } else {\n      measureFocusDelay();\n    }\n  }\n\n  private observeKeyboardResponse() {\n    let keydownTime: number | null = null;\n    \n    document.addEventListener('keydown', (event) => {\n      keydownTime = performance.now();\n    });\n    \n    document.addEventListener('keyup', (event) => {\n      if (keydownTime !== null) {\n        const responseTime = performance.now() - keydownTime;\n        this.metrics.keyboardResponseTime = responseTime;\n        this.notifyCallbacks();\n        keydownTime = null;\n      }\n    });\n  }\n\n  private notifyCallbacks() {\n    this.callbacks.forEach(callback => callback(this.metrics));\n  }\n\n  public onMetricUpdate(callback: (metrics: PerformanceMetrics) => void) {\n    this.callbacks.push(callback);\n  }\n\n  public getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n\n  public disconnect() {\n    this.observers.forEach(observer => observer.disconnect());\n    this.observers = [];\n    this.callbacks = [];\n  }\n}\n\n// Resource hints optimization\nexport const resourceHints = {\n  // Preload critical resources\n  preload: (href: string, as: string, crossorigin?: boolean) => {\n    const link = document.createElement('link');\n    link.rel = 'preload';\n    link.href = href;\n    link.as = as;\n    if (crossorigin) link.crossOrigin = 'anonymous';\n    document.head.appendChild(link);\n  },\n\n  // Prefetch future resources\n  prefetch: (href: string) => {\n    const link = document.createElement('link');\n    link.rel = 'prefetch';\n    link.href = href;\n    document.head.appendChild(link);\n  },\n\n  // DNS prefetch for external domains\n  dnsPrefetch: (domain: string) => {\n    const link = document.createElement('link');\n    link.rel = 'dns-prefetch';\n    link.href = `//${domain}`;\n    document.head.appendChild(link);\n  },\n\n  // Preconnect to external origins\n  preconnect: (href: string, crossorigin = false) => {\n    const link = document.createElement('link');\n    link.rel = 'preconnect';\n    link.href = href;\n    if (crossorigin) link.crossOrigin = 'anonymous';\n    document.head.appendChild(link);\n  }\n};\n\n// Critical CSS inlining with accessibility styles\nexport const criticalCSS = {\n  // Inline critical accessibility styles\n  inlineAccessibilityStyles: () => {\n    const styles = `\n      /* Screen reader only utility */\n      .sr-only {\n        position: absolute;\n        width: 1px;\n        height: 1px;\n        padding: 0;\n        margin: -1px;\n        overflow: hidden;\n        clip: rect(0, 0, 0, 0);\n        white-space: nowrap;\n        border: 0;\n      }\n      \n      /* Focus styles for accessibility */\n      *:focus {\n        outline: 2px solid #3B82F6;\n        outline-offset: 2px;\n      }\n      \n      /* High contrast mode support */\n      @media (prefers-contrast: high) {\n        * {\n          border-color: ButtonText;\n        }\n      }\n      \n      /* Reduced motion support */\n      @media (prefers-reduced-motion: reduce) {\n        *,\n        ::before,\n        ::after {\n          animation-duration: 0.01ms !important;\n          animation-iteration-count: 1 !important;\n          transition-duration: 0.01ms !important;\n          scroll-behavior: auto !important;\n        }\n      }\n      \n      /* Loading states with accessibility */\n      .loading {\n        position: relative;\n        pointer-events: none;\n      }\n      \n      .loading::after {\n        content: '';\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        width: 20px;\n        height: 20px;\n        margin: -10px 0 0 -10px;\n        border: 2px solid transparent;\n        border-top-color: currentColor;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n      }\n      \n      @keyframes spin {\n        to { transform: rotate(360deg); }\n      }\n    `;\n    \n    const styleElement = document.createElement('style');\n    styleElement.textContent = styles;\n    document.head.appendChild(styleElement);\n  },\n\n  // Extract and inline critical CSS\n  extractCritical: async (html: string) => {\n    // This would typically use a tool like Critters or similar\n    // For now, return basic critical styles\n    return {\n      html,\n      css: '',\n      ids: [] as string[]\n    };\n  }\n};\n\n// Service Worker utilities with accessibility awareness\nexport const serviceWorker = {\n  // Register service worker with accessibility considerations\n  register: async (swPath = '/sw.js') => {\n    if ('serviceWorker' in navigator) {\n      try {\n        const registration = await navigator.serviceWorker.register(swPath);\n        \n        // Announce service worker updates to screen readers\n        registration.addEventListener('updatefound', () => {\n          const newWorker = registration.installing;\n          if (newWorker) {\n            newWorker.addEventListener('statechange', () => {\n              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n                // Notify user of available update\n                const announcement = document.createElement('div');\n                announcement.setAttribute('aria-live', 'polite');\n                announcement.className = 'sr-only';\n                announcement.textContent = 'A new version of the application is available. Please refresh to update.';\n                document.body.appendChild(announcement);\n                \n                setTimeout(() => {\n                  document.body.removeChild(announcement);\n                }, 5000);\n              }\n            });\n          }\n        });\n        \n        return registration;\n      } catch (error) {\n        console.error('Service Worker registration failed:', error);\n      }\n    }\n  },\n\n  // Update service worker with user notification\n  update: async () => {\n    if ('serviceWorker' in navigator) {\n      const registration = await navigator.serviceWorker.ready;\n      await registration.update();\n    }\n  }\n};\n\n// Bundle optimization utilities\nexport const bundleOptimization = {\n  // Dynamic import with error boundary\n  dynamicImport: async <T>(importFn: () => Promise<T>, fallback?: T): Promise<T> => {\n    try {\n      return await importFn();\n    } catch (error) {\n      console.error('Dynamic import failed:', error);\n      if (fallback) return fallback;\n      throw error;\n    }\n  },\n\n  // Lazy load component with accessibility announcement\n  lazyLoadComponent: <T extends React.ComponentType<any>>(\n    importFn: () => Promise<{ default: T }>,\n    fallback?: React.ComponentType\n  ) => {\n    return React.lazy(async () => {\n      try {\n        const component = await importFn();\n        \n        // Announce successful load to screen readers\n        const announcement = document.createElement('div');\n        announcement.setAttribute('aria-live', 'polite');\n        announcement.className = 'sr-only';\n        announcement.textContent = 'Component loaded successfully';\n        document.body.appendChild(announcement);\n        \n        setTimeout(() => {\n          document.body.removeChild(announcement);\n        }, 1000);\n        \n        return component;\n      } catch (error) {\n        console.error('Component lazy loading failed:', error);\n        throw error;\n      }\n    });\n  }\n};\n\n// Error boundary with accessibility\nexport class AccessibleErrorBoundary extends React.Component<\n  { children: React.ReactNode; fallback?: React.ComponentType<{ error: Error }> },\n  { hasError: boolean; error?: Error }\n> {\n  constructor(props: any) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Accessible Error Boundary caught an error:', error, errorInfo);\n    \n    // Announce error to screen readers\n    const announcement = document.createElement('div');\n    announcement.setAttribute('aria-live', 'assertive');\n    announcement.setAttribute('role', 'alert');\n    announcement.className = 'sr-only';\n    announcement.textContent = 'An error occurred while loading content. Please try refreshing the page.';\n    document.body.appendChild(announcement);\n    \n    setTimeout(() => {\n      if (document.body.contains(announcement)) {\n        document.body.removeChild(announcement);\n      }\n    }, 5000);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        const FallbackComponent = this.props.fallback;\n        return <FallbackComponent error={this.state.error!} />;\n      }\n      \n      return (\n        <div \n          role=\"alert\" \n          className=\"error-boundary p-8 text-center bg-red-50 border border-red-200 rounded-lg\"\n          aria-labelledby=\"error-title\"\n        >\n          <h2 id=\"error-title\" className=\"text-xl font-semibold text-red-800 mb-4\">\n            Something went wrong\n          </h2>\n          <p className=\"text-red-600 mb-4\">\n            We're sorry, but something unexpected happened. Please try refreshing the page.\n          </p>\n          <button \n            onClick={() => window.location.reload()}\n            className=\"bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500\"\n          >\n            Refresh Page\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Performance monitoring setup\nexport const setupPerformanceMonitoring = () => {\n  const observer = new AccessiblePerformanceObserver();\n  \n  observer.onMetricUpdate((metrics) => {\n    // Send metrics to analytics (respecting privacy)\n    if (typeof window !== 'undefined' && 'gtag' in window) {\n      // Report Core Web Vitals\n      if (metrics.lcp) {\n        (window as any).gtag('event', 'web_vitals', {\n          name: 'LCP',\n          value: metrics.lcp,\n          event_category: 'Performance'\n        });\n      }\n      \n      if (metrics.fid) {\n        (window as any).gtag('event', 'web_vitals', {\n          name: 'FID',\n          value: metrics.fid,\n          event_category: 'Performance'\n        });\n      }\n      \n      if (metrics.cls) {\n        (window as any).gtag('event', 'web_vitals', {\n          name: 'CLS',\n          value: metrics.cls,\n          event_category: 'Performance'\n        });\n      }\n      \n      // Report accessibility metrics\n      if (metrics.focusDelay) {\n        (window as any).gtag('event', 'accessibility_metric', {\n          name: 'focus_delay',\n          value: metrics.focusDelay,\n          event_category: 'Accessibility'\n        });\n      }\n    }\n  });\n  \n  return observer;\n};\n\n// Initialize critical performance optimizations\nexport const initializePerformanceOptimizations = () => {\n  // Inline critical accessibility styles\n  criticalCSS.inlineAccessibilityStyles();\n  \n  // Setup resource hints\n  resourceHints.preconnect('https://fonts.googleapis.com');\n  resourceHints.preconnect('https://fonts.gstatic.com', true);\n  resourceHints.dnsPrefetch('www.google-analytics.com');\n  \n  // Register service worker\n  serviceWorker.register();\n  \n  // Setup performance monitoring\n  return setupPerformanceMonitoring();\n};"